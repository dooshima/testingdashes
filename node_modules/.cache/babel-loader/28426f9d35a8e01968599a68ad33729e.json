{"ast":null,"code":"module.exports = initials; // extend public API\n\ninitials.addTo = addInitialsTo;\ninitials.parse = parse;\ninitials.find = initials; // defaults\n\nvar defaultLength = 2; // there is no support for look-behinds in JS, and the \\b selector\n// doesn't work with diacritics. So we maintain a blacklist of\n// \"non letters\", that we use later to build our regex.\n\nvar nonLetters = ' -\\\\/:-@\\\\[-`\\\\{-\\\\~'; // regex patterns\n\nvar uppercaseLettersOnlyPattern = /^[A-Z]+$/;\nvar initialsInNamePattern = /\\(([^\\)]+)\\)/;\nvar nameIsEmailPattern = /^[^\\s]+@[^\\s]+$/;\nvar findDomainInEmailPattern = /@[^\\s]+/;\nvar findEmailPattern = /[\\w\\._-]+@[\\w\\.-]+[\\w]/g; // match everything that is a \"non letter\" (see above)\n// followed by all but a \"non letter\".\n// Expl: \"Jörg Jäger-Franke\" => [\"J\", \" J\", \"-F\"]\n\nvar findFirstLettersOfWordsPattern = new RegExp('(^|[' + nonLetters + '])[^' + nonLetters + ']', 'g');\nvar findAllNonCharactersPattern = new RegExp('[' + nonLetters + ']', 'g'); // PUBLIC API METHODS\n//\n// initials allows to be used with either a string or an array of strings\n//\n\nfunction initials(nameOrNames, options) {\n  if (!nameOrNames) return '';\n  if (typeof nameOrNames === 'string') return initialsForSingleName(nameOrNames, normalize(options));\n  return initialsForMultipleNames(nameOrNames, normalize(options));\n} //\n// finds initials in a name and adds them to the right side\n//\n\n\nfunction addInitialsTo(nameOrNames, options) {\n  if (!nameOrNames) return '';\n  if (typeof nameOrNames === 'string') return addInitialsToSingleName(nameOrNames, normalize(options));\n  return addInitialsToMultipleNames(nameOrNames, normalize(options));\n} //\n// extract name, initials, email\n//\n\n\nfunction parse(nameOrNames, options) {\n  if (!nameOrNames) return {};\n  if (typeof nameOrNames === 'string') return parseSingleName(nameOrNames, normalize(options));\n  return parseMultipleNames(nameOrNames, normalize(options));\n} // HELPER METHODS\n//\n// Find initials in a single given name string\n//\n\n\nfunction initialsForSingleName(name, options) {\n  var matches;\n  var result;\n  var initials;\n  var length = options.length || 2;\n  initials = findPreferredInitials(name, options);\n  if (initials) return initials;\n  name = cleanupName(name);\n  if (!name) return ''; // there is no support for look-behinds in JS, and the \\b selector\n  // doesn't work with diacritics. So we match everything that is a\n  // \"non character\" followed by all but a \"non character\". To fix\n  // that, we map the results to its last character.\n  // Expl: \"Jörg Jäger\" => [\"J\", \" J\"] => [\"J\", \"J\"]\n\n  matches = name.match(findFirstLettersOfWordsPattern).map(function (match) {\n    return match[match.length - 1];\n  });\n\n  if (matches.length < 2) {\n    if (name.length > length) {\n      return name.substr(0, length);\n    } else {\n      return name;\n    }\n  } else {\n    result = matches.join('');\n  }\n\n  if (result.length >= length) {\n    return result;\n  } // This is where it gets complicated.\n  // Let's say we're in initials('John Doe', 3), so up to here\n  // we have `result === 'JD'`, but what we want is `result === `JDo`.\n  // First, we calculate all remaining options that we have\n\n\n  var possibleInitials = getPossibleInitialsForName(name);\n  var option; // then we return the first option that has the required length\n\n  for (var i = 0; i < possibleInitials.length; i++) {\n    if (possibleInitials[i].length >= length) return possibleInitials[i];\n  }\n\n  ; // if that didn't work, we return the last possible option\n\n  return option;\n} //\n//\n//\n\n\nfunction initialsForMultipleNames(names, options) {\n  var optionsForNames = [];\n  var optionsCountForNames;\n  var map = {};\n  var duplicatesMap = {};\n  var initialsForNamesMap = {};\n  var initials;\n  var possibleInitials;\n  var length = options.length || 2; // get all possible initials for all names for given length\n\n  names.forEach(function (name) {\n    // normalize\n    if (!name) name = ''; // known name? Gets same initials, stop here\n\n    if (initialsForNamesMap[name]) return; // too short to extract initials from? Use name as initials.\n\n    if (name.length < length) {\n      initialsForNamesMap[name] = [name];\n      return;\n    } // preferred initials like (JD)? Use these\n\n\n    initials = findPreferredInitials(name, options);\n\n    if (initials) {\n      map[initials] = 1;\n      initialsForNamesMap[name] = [initials];\n      return;\n    } // return all possible initials for given length\n\n\n    possibleInitials = getPossibleInitialsForName(name).filter(function (initials) {\n      if (initials.length !== length) return false;\n      if (map[initials]) duplicatesMap[initials] = 1;\n      map[initials] = 1;\n      return true;\n    });\n    initialsForNamesMap[name] = possibleInitials;\n  }); // remove duplicates\n\n  var keys = [];\n\n  for (var k in initialsForNamesMap) {\n    keys.unshift(k);\n  }\n\n  for (var c = keys.length, n = 0; n < c; n++) {\n    possibleInitials = initialsForNamesMap[keys[n]];\n    optionsForNames.push(possibleInitials);\n\n    for (var i = 0; i < possibleInitials.length; i++) {\n      if (duplicatesMap[possibleInitials[i]] > 0) {\n        duplicatesMap[possibleInitials[i]]--;\n        possibleInitials.splice(i, 1);\n      }\n    }\n  } // make sure we still have options for every name\n\n\n  optionsCountForNames = optionsForNames.map(function (options) {\n    return options.length;\n  }); // if names were empty, optionsCountForNames is empty. In that case stop here\n\n  if (optionsCountForNames.length === 0) return names;\n\n  if (Math.min.apply(null, optionsCountForNames) === 0) {\n    options.length++;\n    return initialsForMultipleNames(names, options);\n  } // if we do, return the first option for each\n\n\n  return names.map(function (name) {\n    return initialsForNamesMap[name][0];\n  });\n} //\n//\n//\n\n\nfunction addInitialsToSingleName(name, options) {\n  var parts = parseSingleName(name, options);\n  return format(parts);\n} //\n//\n//\n\n\nfunction addInitialsToMultipleNames(names, options) {\n  return parseMultipleNames(names, options).map(format);\n} //\n//\n//\n\n\nfunction parseSingleName(name, options) {\n  var initials;\n  var email;\n  var matches;\n  var parts = {};\n  if (!name) return {}; // are initials part of the name?\n\n  initials = findPreferredInitials(name, options);\n\n  if (initials) {\n    // if yes, remove it from name\n    name = name.replace(uppercaseLettersOnlyPattern, '');\n    name = name.replace(initialsInNamePattern, '');\n  } // use preferred initials if passed\n\n\n  if (options.initials) initials = options.initials; // if no initials found yet, extract initials from name\n\n  if (!initials) initials = initialsForSingleName(name, options); // is there an email in the name?\n\n  matches = name.match(findEmailPattern);\n  if (matches != null) email = matches.pop();\n\n  if (email) {\n    // if yes, remove it from name\n    name = name.replace(email, ''); // if the email and the name are the same, initials can not be rendered\n    // the initials method uses email for rendering just when the name is false\n    // see https://github.com/gr2m/initials/issues/7 for more details\n\n    if (name.trim() === '<' + email + '>') {\n      // set the name to undefined\n      name = ''; // fire up the initials again with the email\n\n      if (!initials) {\n        initials = initialsForSingleName(email, options);\n      }\n    }\n  } // clean up the rest\n\n\n  name = name.replace(findAllNonCharactersPattern, ' ').trim(); // do only return what's present\n\n  if (name) parts.name = name;\n  if (initials) parts.initials = initials;\n  if (email) parts.email = email;\n  return parts;\n} //\n//\n//\n\n\nfunction parseMultipleNames(names, options) {\n  var initialsArray = initialsForMultipleNames(names, options);\n  return names.map(function (name, i) {\n    options.existing[name] = initialsArray[i];\n    return parseSingleName(name, options);\n  });\n} //\n//\n//\n\n\nfunction format(parts) {\n  // neither name nor email: return initials\n  if (!parts.name && !parts.email) return parts.initials; // no email: return name with initials\n\n  if (!parts.email) return parts.name + ' (' + parts.initials + ')'; // no name: return email with initials\n\n  if (!parts.name) return parts.email + ' (' + parts.initials + ')'; // return name with initials & name\n\n  return parts.name + ' (' + parts.initials + ') <' + parts.email + '>';\n} //\n//\n//\n\n\nfunction cleanupName(name) {\n  // in case the name is an email address, remove the @xx.yy part\n  // otherwise remove an eventual email address from name\n  if (nameIsEmailPattern.test(name)) {\n    name = name.replace(findDomainInEmailPattern, '');\n  } else {\n    name = name.replace(findEmailPattern, '');\n  } // replace all non characters with ' ' & trim\n\n\n  name = name.replace(findAllNonCharactersPattern, ' ').trim();\n  return name;\n} //\n//\n//\n\n\nfunction findPreferredInitials(name, options) {\n  var matches; // if preferred initials passed for current name\n\n  if (options.existing[name]) return options.existing[name]; // if the name contains only upcase letters, let's take it as the initials as well\n\n  if (uppercaseLettersOnlyPattern.test(name)) {\n    return name;\n  } // are the initials part of the given name, e.g. »Eddie Murphie (em)«?\n\n\n  matches = name.match(initialsInNamePattern); // if yes, return them\n\n  if (matches != null) {\n    return matches.pop();\n  }\n} //\n// e.g. for John Doe:\n// - JDo\n// - JDoe\n// - JoDoe\n// - JohDoe\n// - JohnDoe\n//\n\n\nvar cache = {};\n\nfunction getPossibleInitialsForName(name) {\n  var parts;\n  var partsPossibilities;\n  var options = [];\n  name = cleanupName(name);\n\n  if (cache[name]) {\n    return cache[name].slice(0); // return copy\n  } // split names into parts\n  // 'John Doe' => ['Doe', 'John']\n\n\n  parts = name.split(' '); // map parts to all its possible initials\n  // 'John' => ['J', 'Jo', 'Joh', 'John']\n\n  partsPossibilities = parts.map(getPossibleInitialsForWord);\n  options = combineAll(partsPossibilities); // sort options, shortest first\n\n  options = options.sort(function (a, b) {\n    return a.length - b.length || options.indexOf(a) - options.indexOf(b);\n  }); // cache for future\n\n  cache[name] = options; // return options\n\n  return options.slice(0);\n} //\n//\n//\n\n\nfunction combineAll(array) {\n  var current = array.shift();\n  var temp;\n  var results;\n\n  if (array.length > 0) {\n    results = [];\n    temp = combineAll(array);\n    current.forEach(function (value1) {\n      temp.forEach(function (value2) {\n        results.push(value1 + value2);\n      });\n    });\n    return results;\n  } else {\n    return current;\n  }\n} //\n//\n//\n\n\nfunction getPossibleInitialsForWord(word) {\n  var options = [];\n\n  while (word.length) {\n    options.unshift(word);\n    word = word.substr(0, word.length - 1);\n  }\n\n  return options;\n} //\n// make sure that options is always an object, and that\n// * options.length is a number and >= defaultLength\n// * existing is set and an object\n//\n\n\nfunction normalize(options) {\n  if (!options) options = {\n    length: defaultLength\n  };\n  if (typeof options === 'number') options = {\n    length: options\n  };\n  options.length = Math.max(options.length || 0, defaultLength);\n  options.existing = options.existing || {};\n  return options;\n}","map":{"version":3,"sources":["C:/Users/ANGER DOOSHIMA LOIS/Desktop/medflitdashboard/node_modules/initials/lib/initials.js"],"names":["module","exports","initials","addTo","addInitialsTo","parse","find","defaultLength","nonLetters","uppercaseLettersOnlyPattern","initialsInNamePattern","nameIsEmailPattern","findDomainInEmailPattern","findEmailPattern","findFirstLettersOfWordsPattern","RegExp","findAllNonCharactersPattern","nameOrNames","options","initialsForSingleName","normalize","initialsForMultipleNames","addInitialsToSingleName","addInitialsToMultipleNames","parseSingleName","parseMultipleNames","name","matches","result","length","findPreferredInitials","cleanupName","match","map","substr","join","possibleInitials","getPossibleInitialsForName","option","i","names","optionsForNames","optionsCountForNames","duplicatesMap","initialsForNamesMap","forEach","filter","keys","k","unshift","c","n","push","splice","Math","min","apply","parts","format","email","replace","pop","trim","initialsArray","existing","test","cache","partsPossibilities","slice","split","getPossibleInitialsForWord","combineAll","sort","a","b","indexOf","array","current","shift","temp","results","value1","value2","word","max"],"mappings":"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","sourcesContent":["module.exports = initials\n\n// extend public API\ninitials.addTo = addInitialsTo\ninitials.parse = parse\ninitials.find = initials\n\n// defaults\nvar defaultLength = 2\n\n// there is no support for look-behinds in JS, and the \\b selector\n// doesn't work with diacritics. So we maintain a blacklist of\n// \"non letters\", that we use later to build our regex.\nvar nonLetters = ' -\\\\/:-@\\\\[-`\\\\{-\\\\~'\n// regex patterns\nvar uppercaseLettersOnlyPattern = /^[A-Z]+$/\nvar initialsInNamePattern = /\\(([^\\)]+)\\)/\nvar nameIsEmailPattern = /^[^\\s]+@[^\\s]+$/\nvar findDomainInEmailPattern = /@[^\\s]+/\nvar findEmailPattern = /[\\w\\._-]+@[\\w\\.-]+[\\w]/g\n\n// match everything that is a \"non letter\" (see above)\n// followed by all but a \"non letter\".\n// Expl: \"Jörg Jäger-Franke\" => [\"J\", \" J\", \"-F\"]\nvar findFirstLettersOfWordsPattern = new RegExp('(^|[' + nonLetters + '])[^' + nonLetters + ']', 'g')\nvar findAllNonCharactersPattern = new RegExp('[' + nonLetters + ']', 'g')\n\n// PUBLIC API METHODS\n\n//\n// initials allows to be used with either a string or an array of strings\n//\nfunction initials (nameOrNames, options) {\n  if (!nameOrNames) return ''\n  if (typeof nameOrNames === 'string') return initialsForSingleName(nameOrNames, normalize(options))\n  return initialsForMultipleNames(nameOrNames, normalize(options))\n}\n\n//\n// finds initials in a name and adds them to the right side\n//\nfunction addInitialsTo (nameOrNames, options) {\n  if (!nameOrNames) return ''\n  if (typeof nameOrNames === 'string') return addInitialsToSingleName(nameOrNames, normalize(options))\n  return addInitialsToMultipleNames(nameOrNames, normalize(options))\n}\n\n//\n// extract name, initials, email\n//\nfunction parse (nameOrNames, options) {\n  if (!nameOrNames) return {}\n  if (typeof nameOrNames === 'string') return parseSingleName(nameOrNames, normalize(options))\n  return parseMultipleNames(nameOrNames, normalize(options))\n}\n\n// HELPER METHODS\n\n//\n// Find initials in a single given name string\n//\nfunction initialsForSingleName (name, options) {\n  var matches\n  var result\n  var initials\n  var length = options.length || 2\n\n  initials = findPreferredInitials(name, options)\n  if (initials) return initials\n\n  name = cleanupName(name)\n  if (!name) return ''\n\n  // there is no support for look-behinds in JS, and the \\b selector\n  // doesn't work with diacritics. So we match everything that is a\n  // \"non character\" followed by all but a \"non character\". To fix\n  // that, we map the results to its last character.\n  // Expl: \"Jörg Jäger\" => [\"J\", \" J\"] => [\"J\", \"J\"]\n  matches = name.match(findFirstLettersOfWordsPattern).map(function (match) {\n    return match[match.length - 1]\n  })\n\n  if (matches.length < 2) {\n    if (name.length > length) {\n      return name.substr(0, length)\n    } else {\n      return name\n    }\n  } else {\n    result = matches.join('')\n  }\n\n  if (result.length >= length) {\n    return result\n  }\n\n  // This is where it gets complicated.\n  // Let's say we're in initials('John Doe', 3), so up to here\n  // we have `result === 'JD'`, but what we want is `result === `JDo`.\n\n  // First, we calculate all remaining options that we have\n  var possibleInitials = getPossibleInitialsForName(name)\n  var option\n\n  // then we return the first option that has the required length\n  for (var i = 0; i < possibleInitials.length; i++) {\n    if (possibleInitials[i].length >= length) return possibleInitials[i]\n  };\n\n  // if that didn't work, we return the last possible option\n  return option\n}\n\n//\n//\n//\nfunction initialsForMultipleNames (names, options) {\n  var optionsForNames = []\n  var optionsCountForNames\n  var map = {}\n  var duplicatesMap = {}\n  var initialsForNamesMap = {}\n  var initials\n  var possibleInitials\n  var length = options.length || 2\n\n  // get all possible initials for all names for given length\n  names.forEach(function (name) {\n    // normalize\n    if (!name) name = ''\n\n    // known name? Gets same initials, stop here\n    if (initialsForNamesMap[name]) return\n\n    // too short to extract initials from? Use name as initials.\n    if (name.length < length) {\n      initialsForNamesMap[name] = [name]\n      return\n    }\n\n    // preferred initials like (JD)? Use these\n    initials = findPreferredInitials(name, options)\n    if (initials) {\n      map[initials] = 1\n      initialsForNamesMap[name] = [initials]\n      return\n    }\n\n    // return all possible initials for given length\n    possibleInitials = getPossibleInitialsForName(name).filter(function (initials) {\n      if (initials.length !== length) return false\n      if (map[initials]) duplicatesMap[initials] = 1\n      map[initials] = 1\n      return true\n    })\n\n    initialsForNamesMap[name] = possibleInitials\n  })\n\n  // remove duplicates\n  var keys = []\n  for (var k in initialsForNamesMap) {\n    keys.unshift(k)\n  }\n  for (var c = keys.length, n = 0; n < c; n++) {\n    possibleInitials = initialsForNamesMap[keys[n]]\n    optionsForNames.push(possibleInitials)\n\n    for (var i = 0; i < possibleInitials.length; i++) {\n      if (duplicatesMap[possibleInitials[i]] > 0) {\n        duplicatesMap[possibleInitials[i]]--\n        possibleInitials.splice(i, 1)\n      }\n    }\n  }\n\n  // make sure we still have options for every name\n  optionsCountForNames = optionsForNames.map(function (options) { return options.length })\n\n  // if names were empty, optionsCountForNames is empty. In that case stop here\n  if (optionsCountForNames.length === 0) return names\n\n  if (Math.min.apply(null, optionsCountForNames) === 0) {\n    options.length++\n    return initialsForMultipleNames(names, options)\n  }\n\n  // if we do, return the first option for each\n  return names.map(function (name) { return initialsForNamesMap[name][0] })\n}\n\n//\n//\n//\nfunction addInitialsToSingleName (name, options) {\n  var parts = parseSingleName(name, options)\n  return format(parts)\n}\n\n//\n//\n//\nfunction addInitialsToMultipleNames (names, options) {\n  return parseMultipleNames(names, options).map(format)\n}\n\n//\n//\n//\nfunction parseSingleName (name, options) {\n  var initials\n  var email\n  var matches\n  var parts = {}\n\n  if (!name) return {}\n\n  // are initials part of the name?\n  initials = findPreferredInitials(name, options)\n  if (initials) {\n    // if yes, remove it from name\n    name = name.replace(uppercaseLettersOnlyPattern, '')\n    name = name.replace(initialsInNamePattern, '')\n  }\n\n  // use preferred initials if passed\n  if (options.initials) initials = options.initials\n\n  // if no initials found yet, extract initials from name\n  if (!initials) initials = initialsForSingleName(name, options)\n\n  // is there an email in the name?\n  matches = name.match(findEmailPattern)\n  if (matches != null) email = matches.pop()\n  if (email) {\n    // if yes, remove it from name\n    name = name.replace(email, '')\n\n    // if the email and the name are the same, initials can not be rendered\n    // the initials method uses email for rendering just when the name is false\n    // see https://github.com/gr2m/initials/issues/7 for more details\n    if (name.trim() === '<' + email + '>') {\n      // set the name to undefined\n      name = ''\n\n      // fire up the initials again with the email\n      if (!initials) {\n        initials = initialsForSingleName(email, options)\n      }\n    }\n  }\n\n  // clean up the rest\n  name = name.replace(findAllNonCharactersPattern, ' ').trim()\n\n  // do only return what's present\n  if (name) parts.name = name\n  if (initials) parts.initials = initials\n  if (email) parts.email = email\n\n  return parts\n}\n\n//\n//\n//\nfunction parseMultipleNames (names, options) {\n  var initialsArray = initialsForMultipleNames(names, options)\n\n  return names.map(function (name, i) {\n    options.existing[name] = initialsArray[i]\n    return parseSingleName(name, options)\n  })\n}\n\n//\n//\n//\nfunction format (parts) {\n\n  // neither name nor email: return initials\n  if (!parts.name && !parts.email) return parts.initials\n\n  // no email: return name with initials\n  if (!parts.email) return parts.name + ' (' + parts.initials + ')'\n\n  // no name: return email with initials\n  if (!parts.name) return parts.email + ' (' + parts.initials + ')'\n\n  // return name with initials & name\n  return parts.name + ' (' + parts.initials + ') <' + parts.email + '>'\n}\n\n//\n//\n//\nfunction cleanupName (name) {\n  // in case the name is an email address, remove the @xx.yy part\n  // otherwise remove an eventual email address from name\n  if (nameIsEmailPattern.test(name)) {\n    name = name.replace(findDomainInEmailPattern, '')\n  } else {\n    name = name.replace(findEmailPattern, '')\n  }\n\n  // replace all non characters with ' ' & trim\n  name = name.replace(findAllNonCharactersPattern, ' ').trim()\n\n  return name\n}\n\n//\n//\n//\nfunction findPreferredInitials (name, options) {\n  var matches\n\n  // if preferred initials passed for current name\n  if (options.existing[name]) return options.existing[name]\n\n  // if the name contains only upcase letters, let's take it as the initials as well\n  if (uppercaseLettersOnlyPattern.test(name)) {\n    return name\n  }\n\n  // are the initials part of the given name, e.g. »Eddie Murphie (em)«?\n  matches = name.match(initialsInNamePattern)\n\n  // if yes, return them\n  if (matches != null) {\n    return matches.pop()\n  }\n}\n\n//\n// e.g. for John Doe:\n// - JDo\n// - JDoe\n// - JoDoe\n// - JohDoe\n// - JohnDoe\n//\nvar cache = {}\nfunction getPossibleInitialsForName (name) {\n  var parts\n  var partsPossibilities\n  var options = []\n\n  name = cleanupName(name)\n\n  if (cache[name]) {\n    return cache[name].slice(0) // return copy\n  }\n\n  // split names into parts\n  // 'John Doe' => ['Doe', 'John']\n  parts = name.split(' ')\n\n  // map parts to all its possible initials\n  // 'John' => ['J', 'Jo', 'Joh', 'John']\n  partsPossibilities = parts.map(getPossibleInitialsForWord)\n\n  options = combineAll(partsPossibilities)\n\n  // sort options, shortest first\n  options = options.sort(function (a, b) {\n    return a.length - b.length || options.indexOf(a) - options.indexOf(b)\n  })\n\n  // cache for future\n  cache[name] = options\n\n  // return options\n  return options.slice(0)\n}\n\n//\n//\n//\nfunction combineAll (array) {\n  var current = array.shift()\n  var temp\n  var results\n  if (array.length > 0) {\n    results = []\n    temp = combineAll(array)\n    current.forEach(function (value1) {\n      temp.forEach(function (value2) {\n        results.push(value1 + value2)\n      })\n    })\n    return results\n  } else {\n    return current\n  }\n}\n\n//\n//\n//\nfunction getPossibleInitialsForWord (word) {\n  var options = []\n  while (word.length) {\n    options.unshift(word)\n    word = word.substr(0, word.length - 1)\n  }\n  return options\n}\n\n//\n// make sure that options is always an object, and that\n// * options.length is a number and >= defaultLength\n// * existing is set and an object\n//\nfunction normalize (options) {\n  if (!options) options = {length: defaultLength}\n  if (typeof options === 'number') options = {length: options}\n\n  options.length = Math.max(options.length || 0, defaultLength)\n  options.existing = options.existing || {}\n\n  return options\n}\n"]},"metadata":{},"sourceType":"script"}